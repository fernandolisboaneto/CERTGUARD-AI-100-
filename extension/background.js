/**
 * CertGuard AI Extension - Background Service Worker
 * Gerencia comunica√ß√£o com backend, detec√ß√£o de sites e seguran√ßa
 */

class CertGuardBackground {
    constructor() {
        this.apiBase = 'https://8081-ick1rotydcjwas9kzjqp5-50bdaabf.manusvm.computer/api';
        this.homologatedSites = [
            'tjrj.jus.br',
            'tjsp.jus.br',
            'trf2.jus.br',
            'pje.jus.br',
            'esaj.tjsp.jus.br',
            'projudi.tjrj.jus.br'
        ];
        this.activeConnections = new Map();
        this.auditLog = [];
        
        this.init();
    }
    
    init() {
        console.log('üöÄ CertGuard AI Background Service Worker iniciado');
        
        // Listeners para eventos da extens√£o
        this.setupEventListeners();
        
        // Verificar sites ativos periodicamente
        this.startSiteMonitoring();
        
        // Limpar dados antigos
        this.cleanupOldData();
    }
    
    setupEventListeners() {\n        // Instala√ß√£o da extens√£o\n        chrome.runtime.onInstalled.addListener((details) => {\n            this.handleInstallation(details);\n        });\n        \n        // Mensagens do popup e content scripts\n        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n            this.handleMessage(message, sender, sendResponse);\n            return true; // Manter canal aberto para resposta ass√≠ncrona\n        });\n        \n        // Mudan√ßas de aba\n        chrome.tabs.onActivated.addListener((activeInfo) => {\n            this.handleTabChange(activeInfo);\n        });\n        \n        // Atualiza√ß√µes de URL\n        chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n            this.handleTabUpdate(tabId, changeInfo, tab);\n        });\n        \n        // Conex√µes externas (do dashboard)\n        chrome.runtime.onMessageExternal.addListener((message, sender, sendResponse) => {\n            this.handleExternalMessage(message, sender, sendResponse);\n            return true;\n        });\n    }\n    \n    handleInstallation(details) {\n        console.log('üì¶ Extens√£o instalada:', details.reason);\n        \n        if (details.reason === 'install') {\n            // Primeira instala√ß√£o\n            this.logAuditEvent('extension_installed', {\n                version: chrome.runtime.getManifest().version,\n                timestamp: new Date().toISOString()\n            });\n            \n            // Abrir p√°gina de boas-vindas\n            chrome.tabs.create({\n                url: 'https://8081-ick1rotydcjwas9kzjqp5-50bdaabf.manusvm.computer'\n            });\n            \n        } else if (details.reason === 'update') {\n            // Atualiza√ß√£o\n            this.logAuditEvent('extension_updated', {\n                previousVersion: details.previousVersion,\n                currentVersion: chrome.runtime.getManifest().version,\n                timestamp: new Date().toISOString()\n            });\n        }\n    }\n    \n    async handleMessage(message, sender, sendResponse) {\n        try {\n            console.log('üì® Mensagem recebida:', message.action, sender);\n            \n            switch (message.action) {\n                case 'siteDetected':\n                    await this.handleSiteDetection(message.siteInfo, sender);\n                    sendResponse({ success: true });\n                    break;\n                    \n                case 'authenticate':\n                    const authResult = await this.handleAuthentication(message, sender);\n                    sendResponse(authResult);\n                    break;\n                    \n                case 'validateExtension':\n                    const validationResult = await this.validateExtensionRequest(message, sender);\n                    sendResponse(validationResult);\n                    break;\n                    \n                case 'getAuditLog':\n                    sendResponse({ auditLog: this.auditLog });\n                    break;\n                    \n                case 'clearSession':\n                    await this.clearUserSession(message.userId);\n                    sendResponse({ success: true });\n                    break;\n                    \n                default:\n                    console.warn('‚ö†Ô∏è A√ß√£o n√£o reconhecida:', message.action);\n                    sendResponse({ success: false, error: 'A√ß√£o n√£o reconhecida' });\n            }\n            \n        } catch (error) {\n            console.error('‚ùå Erro ao processar mensagem:', error);\n            sendResponse({ success: false, error: error.message });\n        }\n    }\n    \n    async handleSiteDetection(siteInfo, sender) {\n        console.log('üîç Site detectado:', siteInfo);\n        \n        // Verificar se √© um site homologado\n        const isHomologated = this.homologatedSites.some(site => \n            siteInfo.hostname.includes(site)\n        );\n        \n        if (isHomologated) {\n            // Atualizar badge da extens√£o\n            chrome.action.setBadgeText({\n                text: '!',\n                tabId: sender.tab.id\n            });\n            \n            chrome.action.setBadgeBackgroundColor({\n                color: '#4ade80',\n                tabId: sender.tab.id\n            });\n            \n            // Log de auditoria\n            this.logAuditEvent('homologated_site_detected', {\n                hostname: siteInfo.hostname,\n                tribunal: siteInfo.tribunal,\n                tabId: sender.tab.id,\n                timestamp: new Date().toISOString()\n            });\n            \n            // Notificar backend sobre detec√ß√£o\n            await this.notifyBackendSiteDetection(siteInfo, sender);\n            \n        } else {\n            // Limpar badge\n            chrome.action.setBadgeText({\n                text: '',\n                tabId: sender.tab.id\n            });\n        }\n    }\n    \n    async handleAuthentication(message, sender) {\n        console.log('üîê Processando autentica√ß√£o:', message);\n        \n        try {\n            // Validar requisi√ß√£o\n            const validation = await this.validateAuthenticationRequest(message, sender);\n            if (!validation.valid) {\n                throw new Error(validation.error);\n            }\n            \n            // Preparar dados para o backend\n            const authData = {\n                userId: message.userId,\n                siteUrl: sender.tab.url,\n                hostname: new URL(sender.tab.url).hostname,\n                timestamp: new Date().toISOString(),\n                tabId: sender.tab.id,\n                userAgent: message.userAgent || 'Unknown',\n                geolocation: message.location || null\n            };\n            \n            // Enviar para backend LucIA\n            const backendResponse = await this.sendToBackend('/extensao/validar', authData);\n            \n            if (backendResponse.success) {\n                // Log de auditoria\n                this.logAuditEvent('authentication_success', {\n                    userId: message.userId,\n                    hostname: authData.hostname,\n                    certificateType: backendResponse.certificateType,\n                    timestamp: new Date().toISOString()\n                });\n                \n                return {\n                    success: true,\n                    certificateType: backendResponse.certificateType,\n                    certificateInfo: backendResponse.certificateInfo,\n                    authMethod: backendResponse.authMethod,\n                    sessionId: backendResponse.sessionId\n                };\n                \n            } else {\n                throw new Error(backendResponse.error || 'Falha na autentica√ß√£o');\n            }\n            \n        } catch (error) {\n            console.error('‚ùå Erro na autentica√ß√£o:', error);\n            \n            // Log de auditoria\n            this.logAuditEvent('authentication_failed', {\n                userId: message.userId,\n                error: error.message,\n                timestamp: new Date().toISOString()\n            });\n            \n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    \n    async validateExtensionRequest(message, sender) {\n        console.log('‚úÖ Validando requisi√ß√£o da extens√£o');\n        \n        try {\n            // Verificar origem\n            if (!sender.tab || !sender.tab.url) {\n                throw new Error('Origem inv√°lida');\n            }\n            \n            const url = new URL(sender.tab.url);\n            const isHomologated = this.homologatedSites.some(site => \n                url.hostname.includes(site)\n            );\n            \n            if (!isHomologated) {\n                throw new Error('Site n√£o homologado');\n            }\n            \n            // Verificar token de autentica√ß√£o\n            const authData = await chrome.storage.local.get(['authToken', 'userInfo']);\n            if (!authData.authToken || !authData.userInfo) {\n                throw new Error('Usu√°rio n√£o autenticado');\n            }\n            \n            // Validar token com backend\n            const tokenValid = await this.validateTokenWithBackend(authData.authToken);\n            if (!tokenValid) {\n                throw new Error('Token inv√°lido ou expirado');\n            }\n            \n            return {\n                valid: true,\n                userInfo: authData.userInfo,\n                siteInfo: {\n                    hostname: url.hostname,\n                    isHomologated: true\n                }\n            };\n            \n        } catch (error) {\n            console.error('‚ùå Valida√ß√£o falhou:', error);\n            return {\n                valid: false,\n                error: error.message\n            };\n        }\n    }\n    \n    async sendToBackend(endpoint, data) {\n        try {\n            const response = await fetch(`${this.apiBase}${endpoint}`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Extension-Version': chrome.runtime.getManifest().version\n                },\n                body: JSON.stringify(data)\n            });\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            return await response.json();\n            \n        } catch (error) {\n            console.error('‚ùå Erro na comunica√ß√£o com backend:', error);\n            \n            // Simular resposta para desenvolvimento\n            return this.simulateBackendResponse(endpoint, data);\n        }\n    }\n    \n    simulateBackendResponse(endpoint, data) {\n        console.log('üîÑ Simulando resposta do backend para:', endpoint);\n        \n        if (endpoint === '/extensao/validar') {\n            return {\n                success: true,\n                certificateType: 'A1',\n                certificateInfo: {\n                    type: 'A1',\n                    owner: 'Jo√£o Silva',\n                    expiry: '2025-12-31',\n                    serial: 'CG123456789',\n                    organization: 'Silva & Associados'\n                },\n                authMethod: 'hsm',\n                sessionId: 'sess-' + Date.now()\n            };\n        }\n        \n        return { success: false, error: 'Endpoint n√£o implementado' };\n    }\n    \n    async validateTokenWithBackend(token) {\n        try {\n            const response = await this.sendToBackend('/auth/validate', { token });\n            return response.success;\n        } catch (error) {\n            console.error('‚ùå Erro ao validar token:', error);\n            return false;\n        }\n    }\n    \n    async notifyBackendSiteDetection(siteInfo, sender) {\n        try {\n            await this.sendToBackend('/extensao/site-detectado', {\n                siteInfo,\n                tabId: sender.tab.id,\n                timestamp: new Date().toISOString()\n            });\n        } catch (error) {\n            console.error('‚ùå Erro ao notificar backend:', error);\n        }\n    }\n    \n    handleTabChange(activeInfo) {\n        console.log('üîÑ Mudan√ßa de aba:', activeInfo.tabId);\n        \n        // Limpar badge da aba anterior\n        chrome.action.setBadgeText({ text: '' });\n        \n        // Verificar nova aba\n        chrome.tabs.get(activeInfo.tabId, (tab) => {\n            if (tab.url) {\n                this.checkTabForHomologatedSite(tab);\n            }\n        });\n    }\n    \n    handleTabUpdate(tabId, changeInfo, tab) {\n        if (changeInfo.url) {\n            console.log('üîÑ URL atualizada:', changeInfo.url);\n            this.checkTabForHomologatedSite(tab);\n        }\n    }\n    \n    checkTabForHomologatedSite(tab) {\n        if (!tab.url) return;\n        \n        try {\n            const url = new URL(tab.url);\n            const isHomologated = this.homologatedSites.some(site => \n                url.hostname.includes(site)\n            );\n            \n            if (isHomologated) {\n                chrome.action.setBadgeText({\n                    text: '!',\n                    tabId: tab.id\n                });\n                \n                chrome.action.setBadgeBackgroundColor({\n                    color: '#4ade80',\n                    tabId: tab.id\n                });\n            } else {\n                chrome.action.setBadgeText({\n                    text: '',\n                    tabId: tab.id\n                });\n            }\n        } catch (error) {\n            console.error('‚ùå Erro ao verificar site:', error);\n        }\n    }\n    \n    handleExternalMessage(message, sender, sendResponse) {\n        console.log('üì® Mensagem externa recebida:', message, sender);\n        \n        // Verificar origem\n        if (!sender.url || !sender.url.includes('manusvm.computer')) {\n            sendResponse({ success: false, error: 'Origem n√£o autorizada' });\n            return;\n        }\n        \n        // Processar mensagem do dashboard\n        switch (message.action) {\n            case 'getExtensionStatus':\n                sendResponse({\n                    success: true,\n                    status: 'active',\n                    version: chrome.runtime.getManifest().version,\n                    auditLog: this.auditLog.slice(-10) // √öltimos 10 eventos\n                });\n                break;\n                \n            default:\n                sendResponse({ success: false, error: 'A√ß√£o n√£o reconhecida' });\n        }\n    }\n    \n    startSiteMonitoring() {\n        // Verificar sites ativos a cada 30 segundos\n        setInterval(() => {\n            this.monitorActiveSites();\n        }, 30000);\n    }\n    \n    async monitorActiveSites() {\n        try {\n            const tabs = await chrome.tabs.query({ active: true });\n            \n            for (const tab of tabs) {\n                if (tab.url) {\n                    this.checkTabForHomologatedSite(tab);\n                }\n            }\n        } catch (error) {\n            console.error('‚ùå Erro no monitoramento:', error);\n        }\n    }\n    \n    logAuditEvent(event, data) {\n        const auditEntry = {\n            id: Date.now(),\n            event,\n            data,\n            timestamp: new Date().toISOString()\n        };\n        \n        this.auditLog.push(auditEntry);\n        \n        // Manter apenas os √∫ltimos 100 eventos\n        if (this.auditLog.length > 100) {\n            this.auditLog = this.auditLog.slice(-100);\n        }\n        \n        console.log('üìù Evento de auditoria:', auditEntry);\n        \n        // Enviar para backend se poss√≠vel\n        this.sendAuditToBackend(auditEntry);\n    }\n    \n    async sendAuditToBackend(auditEntry) {\n        try {\n            await this.sendToBackend('/auditoria/evento', auditEntry);\n        } catch (error) {\n            console.error('‚ùå Erro ao enviar auditoria:', error);\n        }\n    }\n    \n    async clearUserSession(userId) {\n        try {\n            // Limpar storage local\n            await chrome.storage.local.clear();\n            \n            // Limpar badges\n            chrome.action.setBadgeText({ text: '' });\n            \n            // Log de auditoria\n            this.logAuditEvent('session_cleared', {\n                userId,\n                timestamp: new Date().toISOString()\n            });\n            \n            console.log('üßπ Sess√£o limpa para usu√°rio:', userId);\n            \n        } catch (error) {\n            console.error('‚ùå Erro ao limpar sess√£o:', error);\n        }\n    }\n    \n    cleanupOldData() {\n        // Limpar dados antigos a cada hora\n        setInterval(() => {\n            this.performCleanup();\n        }, 3600000); // 1 hora\n    }\n    \n    async performCleanup() {\n        try {\n            console.log('üßπ Executando limpeza de dados antigos');\n            \n            // Verificar e limpar tokens expirados\n            const authData = await chrome.storage.local.get(['authToken', 'userInfo']);\n            if (authData.authToken) {\n                const isValid = await this.validateTokenWithBackend(authData.authToken);\n                if (!isValid) {\n                    await chrome.storage.local.clear();\n                    console.log('üßπ Token expirado removido');\n                }\n            }\n            \n            // Limpar log de auditoria antigo\n            const oneHourAgo = Date.now() - 3600000;\n            this.auditLog = this.auditLog.filter(entry => \n                new Date(entry.timestamp).getTime() > oneHourAgo\n            );\n            \n        } catch (error) {\n            console.error('‚ùå Erro na limpeza:', error);\n        }\n    }\n}\n\n// Inicializar background service worker\nnew CertGuardBackground();

