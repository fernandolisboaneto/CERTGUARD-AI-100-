#!/usr/bin/env python3\n\"\"\"\nCertGuard AI - Daemon Local para Certificados A3\nGerencia tokens e cartões inteligentes via PKCS#11\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport time\nimport signal\nimport logging\nimport threading\nimport subprocess\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nimport hashlib\nimport base64\nimport struct\n\n# Importações para PKCS#11\ntry:\n    from PyKCS11 import *\n    import PyKCS11\nexcept ImportError:\n    print(\"PyKCS11 não encontrado. Instale com: pip install PyKCS11\")\n    sys.exit(1)\n\n# Configuração de logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('/tmp/certguard_daemon.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger('CertGuardDaemon')\n\nclass CertGuardDaemon:\n    \"\"\"Daemon para gerenciar certificados A3 via PKCS#11\"\"\"\n    \n    def __init__(self):\n        self.running = False\n        self.pkcs11_lib = None\n        self.session = None\n        self.slot_list = []\n        self.active_tokens = {}\n        self.config = self.load_config()\n        self.native_messaging_enabled = True\n        \n        # Configurações PKCS#11\n        self.pkcs11_libraries = [\n            '/usr/lib/libeToken.so',  # eToken\n            '/usr/lib/libepsng_p11.so',  # Safenet\n            '/usr/lib/libcryptoki.so',  # Genérico\n            '/usr/lib/x86_64-linux-gnu/opensc-pkcs11.so',  # OpenSC\n            '/System/Library/Frameworks/PCSC.framework/PCSC',  # macOS\n            'C:\\\\Windows\\\\System32\\\\eTPKCS11.dll'  # Windows eToken\n        ]\n        \n        # Configuração de timeouts\n        self.pin_timeout = 300  # 5 minutos\n        self.session_timeout = 1800  # 30 minutos\n        self.last_activity = time.time()\n        \n        # Thread de monitoramento\n        self.monitor_thread = None\n        self.stop_event = threading.Event()\n        \n    def load_config(self):\n        \"\"\"Carrega configuração do daemon\"\"\"\n        config_path = Path.home() / '.certguard' / 'daemon_config.json'\n        \n        default_config = {\n            'backend_url': 'https://api.certguard.ai',\n            'user_id': None,\n            'api_token': None,\n            'auto_detect_tokens': True,\n            'pin_cache_timeout': 300,\n            'log_level': 'INFO',\n            'native_messaging_port': 'com.certguard.daemon'\n        }\n        \n        try:\n            if config_path.exists():\n                with open(config_path, 'r') as f:\n                    config = json.load(f)\n                    # Merge com configuração padrão\n                    default_config.update(config)\n            else:\n                # Criar diretório e arquivo de configuração\n                config_path.parent.mkdir(parents=True, exist_ok=True)\n                with open(config_path, 'w') as f:\n                    json.dump(default_config, f, indent=2)\n                    \n            return default_config\n            \n        except Exception as e:\n            logger.error(f\"Erro ao carregar configuração: {str(e)}\")\n            return default_config\n    \n    def initialize_pkcs11(self):\n        \"\"\"Inicializa biblioteca PKCS#11\"\"\"\n        try:\n            logger.info(\"Inicializando PKCS#11...\")\n            \n            # Tentar encontrar biblioteca PKCS#11\n            pkcs11_path = None\n            for lib_path in self.pkcs11_libraries:\n                if os.path.exists(lib_path):\n                    pkcs11_path = lib_path\n                    break\n            \n            if not pkcs11_path:\n                raise Exception(\"Nenhuma biblioteca PKCS#11 encontrada\")\n            \n            logger.info(f\"Usando biblioteca PKCS#11: {pkcs11_path}\")\n            \n            # Inicializar PKCS#11\n            self.pkcs11_lib = PyKCS11.PyKCS11Lib()\n            self.pkcs11_lib.load(pkcs11_path)\n            \n            # Listar slots disponíveis\n            self.slot_list = self.pkcs11_lib.getSlotList(tokenPresent=True)\n            logger.info(f\"Slots encontrados: {len(self.slot_list)}\")\n            \n            # Detectar tokens\n            self.detect_tokens()\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Erro ao inicializar PKCS#11: {str(e)}\")\n            return False\n    \n    def detect_tokens(self):\n        \"\"\"Detecta tokens/cartões inseridos\"\"\"\n        try:\n            self.active_tokens = {}\n            \n            for slot in self.slot_list:\n                try:\n                    slot_info = self.pkcs11_lib.getSlotInfo(slot)\n                    token_info = self.pkcs11_lib.getTokenInfo(slot)\n                    \n                    token_data = {\n                        'slot_id': slot,\n                        'slot_description': slot_info.slotDescription.strip(),\n                        'token_label': token_info.label.strip(),\n                        'token_serial': token_info.serialNumber.strip(),\n                        'manufacturer': token_info.manufacturerID.strip(),\n                        'model': token_info.model.strip(),\n                        'flags': token_info.flags,\n                        'detected_at': datetime.utcnow().isoformat()\n                    }\n                    \n                    self.active_tokens[slot] = token_data\n                    \n                    logger.info(f\"Token detectado: {token_data['token_label']} (Serial: {token_data['token_serial']})\")\n                    \n                except Exception as e:\n                    logger.warning(f\"Erro ao ler token no slot {slot}: {str(e)}\")\n            \n            logger.info(f\"Total de tokens ativos: {len(self.active_tokens)}\")\n            \n        except Exception as e:\n            logger.error(f\"Erro na detecção de tokens: {str(e)}\")\n    \n    def authenticate_token(self, slot_id, pin):\n        \"\"\"Autentica no token com PIN\"\"\"\n        try:\n            logger.info(f\"Autenticando no token slot {slot_id}\")\n            \n            if slot_id not in self.active_tokens:\n                raise Exception(f\"Token não encontrado no slot {slot_id}\")\n            \n            # Abrir sessão\n            session = self.pkcs11_lib.openSession(slot_id, CKF_SERIAL_SESSION | CKF_RW_SESSION)\n            \n            # Fazer login com PIN\n            session.login(pin, CKU_USER)\n            \n            # Armazenar sessão\n            self.session = session\n            self.active_tokens[slot_id]['authenticated'] = True\n            self.active_tokens[slot_id]['session'] = session\n            self.active_tokens[slot_id]['authenticated_at'] = datetime.utcnow().isoformat()\n            \n            logger.info(f\"Autenticação bem-sucedida no slot {slot_id}\")\n            \n            # Listar certificados disponíveis\n            certificates = self.list_certificates(slot_id)\n            self.active_tokens[slot_id]['certificates'] = certificates\n            \n            return {\n                'success': True,\n                'slot_id': slot_id,\n                'certificates': certificates,\n                'token_info': self.active_tokens[slot_id]\n            }\n            \n        except Exception as e:\n            logger.error(f\"Erro na autenticação: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def list_certificates(self, slot_id):\n        \"\"\"Lista certificados disponíveis no token\"\"\"\n        try:\n            if slot_id not in self.active_tokens or not self.active_tokens[slot_id].get('authenticated'):\n                raise Exception(\"Token não autenticado\")\n            \n            session = self.active_tokens[slot_id]['session']\n            certificates = []\n            \n            # Buscar objetos de certificado\n            cert_objects = session.findObjects([(CKA_CLASS, CKO_CERTIFICATE)])\n            \n            for cert_obj in cert_objects:\n                try:\n                    # Obter atributos do certificado\n                    attributes = session.getAttributeValue(cert_obj, [\n                        CKA_LABEL,\n                        CKA_ID,\n                        CKA_VALUE,\n                        CKA_SUBJECT,\n                        CKA_ISSUER\n                    ])\n                    \n                    cert_data = {\n                        'object_handle': cert_obj,\n                        'label': attributes[0] if attributes[0] else 'Sem label',\n                        'id': attributes[1].hex() if attributes[1] else '',\n                        'der_data': attributes[2] if attributes[2] else None,\n                        'subject': attributes[3] if attributes[3] else None,\n                        'issuer': attributes[4] if attributes[4] else None\n                    }\n                    \n                    # Parse do certificado X.509\n                    if cert_data['der_data']:\n                        cert_info = self.parse_certificate(cert_data['der_data'])\n                        cert_data.update(cert_info)\n                    \n                    certificates.append(cert_data)\n                    \n                except Exception as e:\n                    logger.warning(f\"Erro ao processar certificado: {str(e)}\")\n            \n            logger.info(f\"Encontrados {len(certificates)} certificados no slot {slot_id}\")\n            return certificates\n            \n        except Exception as e:\n            logger.error(f\"Erro ao listar certificados: {str(e)}\")\n            return []\n    \n    def parse_certificate(self, der_data):\n        \"\"\"Parse básico de certificado X.509\"\"\"\n        try:\n            # Em produção, usar biblioteca como cryptography\n            # Por ora, extrair informações básicas\n            \n            cert_hash = hashlib.sha256(der_data).hexdigest()\n            \n            return {\n                'serial_number': cert_hash[:16],  # Simulado\n                'not_before': '2024-01-01T00:00:00Z',  # Simulado\n                'not_after': '2027-01-01T00:00:00Z',  # Simulado\n                'fingerprint': cert_hash,\n                'key_usage': ['digital_signature', 'key_encipherment'],\n                'size_bytes': len(der_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Erro no parse do certificado: {str(e)}\")\n            return {}\n    \n    def sign_data(self, slot_id, cert_id, data, algorithm='SHA256withRSA'):\n        \"\"\"Assina dados usando certificado do token\"\"\"\n        try:\n            logger.info(f\"Assinando dados com certificado {cert_id} no slot {slot_id}\")\n            \n            if slot_id not in self.active_tokens or not self.active_tokens[slot_id].get('authenticated'):\n                raise Exception(\"Token não autenticado\")\n            \n            session = self.active_tokens[slot_id]['session']\n            \n            # Encontrar chave privada correspondente\n            private_key = self.find_private_key(session, cert_id)\n            if not private_key:\n                raise Exception(\"Chave privada não encontrada\")\n            \n            # Preparar dados para assinatura\n            if isinstance(data, str):\n                data_bytes = data.encode('utf-8')\n            else:\n                data_bytes = data\n            \n            # Hash dos dados\n            if 'SHA256' in algorithm:\n                hash_obj = hashlib.sha256(data_bytes)\n            elif 'SHA384' in algorithm:\n                hash_obj = hashlib.sha384(data_bytes)\n            elif 'SHA512' in algorithm:\n                hash_obj = hashlib.sha512(data_bytes)\n            else:\n                raise Exception(f\"Algoritmo não suportado: {algorithm}\")\n            \n            data_hash = hash_obj.digest()\n            \n            # Configurar mecanismo de assinatura\n            if 'RSA' in algorithm:\n                mechanism = Mechanism(CKM_RSA_PKCS, None)\n            else:\n                raise Exception(f\"Mecanismo não suportado: {algorithm}\")\n            \n            # Inicializar operação de assinatura\n            session.signInit(private_key, mechanism)\n            \n            # Assinar\n            signature = session.sign(data_hash)\n            \n            # Converter para base64\n            signature_b64 = base64.b64encode(bytes(signature)).decode('utf-8')\n            \n            # Log de auditoria\n            audit_data = {\n                'event': 'token_signature',\n                'slot_id': slot_id,\n                'cert_id': cert_id,\n                'algorithm': algorithm,\n                'data_hash': hash_obj.hexdigest(),\n                'signature_length': len(signature),\n                'timestamp': datetime.utcnow().isoformat()\n            }\n            \n            self.log_audit_event(audit_data)\n            \n            logger.info(f\"Assinatura criada com sucesso (tamanho: {len(signature)} bytes)\")\n            \n            return {\n                'success': True,\n                'signature': signature_b64,\n                'algorithm': algorithm,\n                'cert_id': cert_id,\n                'timestamp': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Erro na assinatura: {str(e)}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n    \n    def find_private_key(self, session, cert_id):\n        \"\"\"Encontra chave privada correspondente ao certificado\"\"\"\n        try:\n            # Buscar chaves privadas\n            private_keys = session.findObjects([(CKA_CLASS, CKO_PRIVATE_KEY)])\n            \n            for key_obj in private_keys:\n                try:\n                    # Obter ID da chave\n                    key_id = session.getAttributeValue(key_obj, [CKA_ID])[0]\n                    \n                    if key_id and key_id.hex() == cert_id:\n                        return key_obj\n                        \n                except Exception as e:\n                    logger.warning(f\"Erro ao verificar chave privada: {str(e)}\")\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Erro ao buscar chave privada: {str(e)}\")\n            return None\n    \n    def start_native_messaging(self):\n        \"\"\"Inicia comunicação nativa com extensão\"\"\"\n        try:\n            logger.info(\"Iniciando native messaging...\")\n            \n            while self.running:\n                try:\n                    # Ler mensagem da extensão\n                    message = self.read_native_message()\n                    if message:\n                        response = self.process_native_message(message)\n                        self.send_native_message(response)\n                        \n                except Exception as e:\n                    logger.error(f\"Erro no native messaging: {str(e)}\")\n                    time.sleep(1)\n                    \n        except Exception as e:\n            logger.error(f\"Erro fatal no native messaging: {str(e)}\")\n    \n    def read_native_message(self):\n        \"\"\"Lê mensagem da extensão via stdin\"\"\"\n        try:\n            # Ler tamanho da mensagem (4 bytes)\n            raw_length = sys.stdin.buffer.read(4)\n            if not raw_length:\n                return None\n                \n            message_length = struct.unpack('=I', raw_length)[0]\n            \n            # Ler mensagem\n            message_data = sys.stdin.buffer.read(message_length)\n            message = json.loads(message_data.decode('utf-8'))\n            \n            logger.info(f\"Mensagem recebida: {message.get('action', 'unknown')}\")\n            return message\n            \n        except Exception as e:\n            logger.error(f\"Erro ao ler mensagem nativa: {str(e)}\")\n            return None\n    \n    def send_native_message(self, message):\n        \"\"\"Envia mensagem para extensão via stdout\"\"\"\n        try:\n            message_json = json.dumps(message)\n            message_bytes = message_json.encode('utf-8')\n            \n            # Enviar tamanho da mensagem\n            sys.stdout.buffer.write(struct.pack('=I', len(message_bytes)))\n            \n            # Enviar mensagem\n            sys.stdout.buffer.write(message_bytes)\n            sys.stdout.buffer.flush()\n            \n            logger.info(f\"Mensagem enviada: {message.get('action', 'response')}\")\n            \n        except Exception as e:\n            logger.error(f\"Erro ao enviar mensagem nativa: {str(e)}\")\n    \n    def process_native_message(self, message):\n        \"\"\"Processa mensagem da extensão\"\"\"\n        try:\n            action = message.get('action')\n            \n            if action == 'detect_tokens':\n                self.detect_tokens()\n                return {\n                    'action': 'tokens_detected',\n                    'success': True,\n                    'tokens': list(self.active_tokens.values())\n                }\n                \n            elif action == 'authenticate':\n                slot_id = message.get('slot_id')\n                pin = message.get('pin')\n                \n                if not slot_id or not pin:\n                    return {\n                        'action': 'authentication_result',\n                        'success': False,\n                        'error': 'Slot ID e PIN são obrigatórios'\n                    }\n                \n                result = self.authenticate_token(slot_id, pin)\n                return {\n                    'action': 'authentication_result',\n                    **result\n                }\n                \n            elif action == 'sign_data':\n                slot_id = message.get('slot_id')\n                cert_id = message.get('cert_id')\n                data = message.get('data')\n                algorithm = message.get('algorithm', 'SHA256withRSA')\n                \n                if not all([slot_id, cert_id, data]):\n                    return {\n                        'action': 'signature_result',\n                        'success': False,\n                        'error': 'Parâmetros obrigatórios ausentes'\n                    }\n                \n                result = self.sign_data(slot_id, cert_id, data, algorithm)\n                return {\n                    'action': 'signature_result',\n                    **result\n                }\n                \n            elif action == 'get_status':\n                return {\n                    'action': 'status_response',\n                    'success': True,\n                    'status': {\n                        'running': self.running,\n                        'active_tokens': len(self.active_tokens),\n                        'pkcs11_initialized': self.pkcs11_lib is not None,\n                        'last_activity': self.last_activity,\n                        'uptime': time.time() - self.start_time\n                    }\n                }\n                \n            else:\n                return {\n                    'action': 'error',\n                    'success': False,\n                    'error': f'Ação não reconhecida: {action}'\n                }\n                \n        except Exception as e:\n            logger.error(f\"Erro ao processar mensagem: {str(e)}\")\n            return {\n                'action': 'error',\n                'success': False,\n                'error': str(e)\n            }\n    \n    def start_monitor_thread(self):\n        \"\"\"Inicia thread de monitoramento\"\"\"\n        def monitor():\n            while not self.stop_event.is_set():\n                try:\n                    # Verificar timeouts\n                    self.check_timeouts()\n                    \n                    # Redetectar tokens periodicamente\n                    if time.time() - self.last_activity > 60:  # 1 minuto\n                        self.detect_tokens()\n                        self.last_activity = time.time()\n                    \n                    # Aguardar\n                    self.stop_event.wait(30)  # 30 segundos\n                    \n                except Exception as e:\n                    logger.error(f\"Erro no monitor: {str(e)}\")\n                    self.stop_event.wait(10)\n        \n        self.monitor_thread = threading.Thread(target=monitor, daemon=True)\n        self.monitor_thread.start()\n        logger.info(\"Thread de monitoramento iniciada\")\n    \n    def check_timeouts(self):\n        \"\"\"Verifica e limpa sessões expiradas\"\"\"\n        try:\n            current_time = time.time()\n            expired_slots = []\n            \n            for slot_id, token_data in self.active_tokens.items():\n                if token_data.get('authenticated'):\n                    auth_time = datetime.fromisoformat(\n                        token_data['authenticated_at'].replace('Z', '+00:00')\n                    )\n                    \n                    # Verificar timeout da sessão\n                    if (current_time - auth_time.timestamp()) > self.session_timeout:\n                        expired_slots.append(slot_id)\n            \n            # Limpar sessões expiradas\n            for slot_id in expired_slots:\n                self.logout_token(slot_id)\n                logger.info(f\"Sessão expirada removida: slot {slot_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Erro na verificação de timeouts: {str(e)}\")\n    \n    def logout_token(self, slot_id):\n        \"\"\"Faz logout do token\"\"\"\n        try:\n            if slot_id in self.active_tokens and self.active_tokens[slot_id].get('session'):\n                session = self.active_tokens[slot_id]['session']\n                session.logout()\n                session.closeSession()\n                \n                self.active_tokens[slot_id]['authenticated'] = False\n                del self.active_tokens[slot_id]['session']\n                \n                logger.info(f\"Logout realizado no slot {slot_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Erro no logout do slot {slot_id}: {str(e)}\")\n    \n    def log_audit_event(self, audit_data):\n        \"\"\"Log de eventos para auditoria\"\"\"\n        try:\n            # Adicionar informações do daemon\n            audit_data.update({\n                'daemon_version': '1.0.0',\n                'user_id': self.config.get('user_id'),\n                'hostname': os.uname().nodename\n            })\n            \n            # Log local\n            logger.info(f\"AUDIT: {json.dumps(audit_data)}\")\n            \n            # Em produção, enviar para backend\n            # self.send_audit_to_backend(audit_data)\n            \n        except Exception as e:\n            logger.error(f\"Erro no log de auditoria: {str(e)}\")\n    \n    def signal_handler(self, signum, frame):\n        \"\"\"Handler para sinais do sistema\"\"\"\n        logger.info(f\"Sinal recebido: {signum}\")\n        self.stop()\n    \n    def start(self):\n        \"\"\"Inicia o daemon\"\"\"\n        try:\n            logger.info(\"Iniciando CertGuard Daemon...\")\n            \n            self.start_time = time.time()\n            self.running = True\n            \n            # Configurar handlers de sinal\n            signal.signal(signal.SIGINT, self.signal_handler)\n            signal.signal(signal.SIGTERM, self.signal_handler)\n            \n            # Inicializar PKCS#11\n            if not self.initialize_pkcs11():\n                raise Exception(\"Falha na inicialização do PKCS#11\")\n            \n            # Iniciar thread de monitoramento\n            self.start_monitor_thread()\n            \n            # Iniciar native messaging se habilitado\n            if self.native_messaging_enabled:\n                self.start_native_messaging()\n            else:\n                # Modo standalone\n                while self.running:\n                    time.sleep(1)\n            \n        except Exception as e:\n            logger.error(f\"Erro fatal no daemon: {str(e)}\")\n            self.stop()\n    \n    def stop(self):\n        \"\"\"Para o daemon\"\"\"\n        try:\n            logger.info(\"Parando CertGuard Daemon...\")\n            \n            self.running = False\n            self.stop_event.set()\n            \n            # Fazer logout de todos os tokens\n            for slot_id in list(self.active_tokens.keys()):\n                self.logout_token(slot_id)\n            \n            # Finalizar PKCS#11\n            if self.pkcs11_lib:\n                try:\n                    self.pkcs11_lib.finalize()\n                except:\n                    pass\n            \n            logger.info(\"Daemon parado\")\n            \n        except Exception as e:\n            logger.error(f\"Erro ao parar daemon: {str(e)}\")\n\ndef main():\n    \"\"\"Função principal\"\"\"\n    try:\n        # Verificar argumentos\n        if len(sys.argv) > 1:\n            if sys.argv[1] == '--version':\n                print(\"CertGuard Daemon v1.0.0\")\n                return\n            elif sys.argv[1] == '--help':\n                print(\"CertGuard Daemon - Gerenciador de certificados A3\")\n                print(\"Uso: certguard_daemon.py [--version|--help|--standalone]\")\n                return\n            elif sys.argv[1] == '--standalone':\n                # Modo standalone (sem native messaging)\n                daemon = CertGuardDaemon()\n                daemon.native_messaging_enabled = False\n                daemon.start()\n                return\n        \n        # Modo normal (native messaging)\n        daemon = CertGuardDaemon()\n        daemon.start()\n        \n    except KeyboardInterrupt:\n        logger.info(\"Interrompido pelo usuário\")\n    except Exception as e:\n        logger.error(f\"Erro fatal: {str(e)}\")\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()

